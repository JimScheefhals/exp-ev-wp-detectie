import pandas as pd
import numpy as np
import random
import plotly.graph_objects as go

from ev_detection.src.input.baseload_profiles import BaseloadProfiles
from ev_detection.src.input.charging_profile import ChargingProfiles
from ev_detection.src.types.profiles import WeekProfile

charging_profiles = ChargingProfiles()
baseload_profiles = BaseloadProfiles()

class LoadProfiles:

    def render_samples(
            self, n_profiles: int, ratio_positives: float = 0.5
    ) -> tuple[dict[int, WeekProfile], pd.DataFrame]:
        """
        Create a randomly ordered set of positive and negative samples.
        :param n_profiles: total number of profiles
        :param ratio_positives: ratio of positive profiles
        :return: tuple containing:
         - a dict of combined positive and negative synthetic profiles and their id's,
         - a dataframe with the id's and their corresponding labels (positive=True, negative=False)
        """
        # render the samples
        positive_samples, meta_data_pos = self.render_synthetic_positives(int(n_profiles * ratio_positives))
        negative_samples, meta_data_neg = self.render_negatives(int(n_profiles * (1 - ratio_positives)))

        # update id's to be unique
        last_id = max(positive_samples.keys())
        negative_samples = {i + last_id: profile for i, profile in negative_samples.items()}
        meta_data_neg["id"] = meta_data_neg["id"] + last_id

        # combine the samples and meta_data
        samples = positive_samples.copy()
        samples.update(negative_samples)
        meta_data = pd.concat([meta_data_pos, meta_data_neg], ignore_index=True)

        samples, meta_data = self._shuffle_samples(samples, meta_data)
        return samples, meta_data

    def _shuffle_samples(self, samples: dict[int, WeekProfile], meta_data: pd.DataFrame) -> tuple[dict[int, WeekProfile], pd.DataFrame]:
        """
        Shuffle the samples and the meta_data.
        :param samples: the samples to shuffle
        :param meta_data: the meta_data to shuffle
        :return: shuffled samples and meta_data
        """
        ids = list(samples.keys())
        random.shuffle(ids)
        samples = {new_id: samples[old_id] for new_id, old_id in enumerate(ids)}
        meta_data = meta_data.loc[ids].reset_index(drop=True)
        meta_data["id"] = meta_data.index
        return samples, meta_data

    def render_synthetic_positives(self, n_profiles: int) -> list[WeekProfile]:
        """
        Generate synthetic profiles by combining samples from PULSE baseload profiles with E-laad charging profiles.
        The profiles cover one week and the interval is 15 minutes and contain a charging profile.
        :param n_profiles: The number of profiles to generate
        :return: synthetic smart meter data
        """
        charging, meta_data_c = charging_profiles.sample_weekly_profiles(n_profiles)
        baseload, meta_data_b = baseload_profiles.sample_weekly_profiles(n_profiles)
        meta_data = meta_data_b.merge(meta_data_c, on="id")
        meta_data["label"] = True
        return {
            i: baseload[i].reset_index(drop=True) + charging[i].reset_index(drop=True)
            for i in range(n_profiles)
        }, meta_data

    def render_negatives(self, n_profiles: int) -> list[pd.Series]:
        """
        Generate negative profiles by sampling PULSE baseload profiles.
        The profiles cover one week and the interval is 15 minutes and are assumed to not contain a charging profile.
        :param n_profiles: The number of profiles to generate
        :return: synthetic smart meter data
        """
        profile, meta_data = baseload_profiles.sample_weekly_profiles(n_profiles)
        meta_data["label"] = False
        return profile, meta_data

    def get_datetimes(self):
        """
        :return: timestamps for the profiles generated by self.render()
        """
        return charging_profiles.get_datetimes_week().reset_index(drop=True)

    def show_profile_components(self, profile_id: int, meta_data: pd.DataFrame):
        """
        Plot the individual components of the synthetic profiles.
        Assuming these are build up using _baseload & _charging.
        :param profile_id: the id of the profile
        """
        _info = meta_data[meta_data["id"] == profile_id]
        datetime = charging_profiles.get_datetimes_week()



        fig = go.Figure()

        baseload_profile = baseload_profiles.get_profile_by_id_week(
            _info.PULSE_id,
            _info.PULSE_week
        )
        fig.add_trace(go.Scatter(x=datetime, y=baseload_profile, mode='lines', name='baseload', showlegend=True))

        if ~np.isnan(_info.charging_id):
            charging_profile = charging_profiles.get_profile_by_id_week(
                int(_info.charging_id),
                int(_info.charging_week)
            )
            fig.add_trace(go.Scatter(x=datetime, y=charging_profile, mode='lines', name='charging', showlegend=True))

        fig.update_layout(
            title="Synthetic profiles",
            xaxis_title="Date",
            yaxis_title="Power [kW]",
        )
        fig.show()

if __name__ == "__main__":
    profiles = LoadProfiles()
    samples, meta_data = profiles.render_samples(10)
    datetime = profiles.get_datetimes()
    profiles.show_profile_components(1, meta_data)